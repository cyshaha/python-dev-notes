# sql优化

## sql执行顺序

FROM → ON → JOIN → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT



## 慢查询原因

1、查询语句写的不好

2、索引失效

3、join连表太多



## 索引分类

**一 逻辑上分类**

1、主键索引

设定为主键后数据库会自动建立索引，唯一且不为能空，innodb为聚簇索引

2、单值索引

即一个索引只包含单个列，一个表可以有多个单列索引

3、唯一索引

索引列的值必须唯一，但允许有空值

4、复合索引

即一个索引包含多个列

在数据库操作期间，复合索引比单值索引所需要的开销更小(对于相同的多个列建索引)

当表的行数远大于索引列的数目时可以使用复合索引。

但是注意，建立复合索引时，字段顺序是影响索引效果的，如果不使用复合索引的第一个列，则复合索引就会失效。例如建立ab两列的复合索引，where条件只用到b，则不会使用这个复合索引。



**二 从物理存储角度**
1、聚簇索引（clustered index）

索引上只存储了索引值

InnoDB默认对主键建立聚簇索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替

2、非聚簇索引（non-clustered index）

不仅存储了索引值还存储了数据



**三 数据结构上分类**

1、B+树索引
2、hash索引
3、FULLTEXT索引
4、R-Tree索引



## 关于建立索引

### 哪些需要建

1、主键自动建立唯一非空索引

2、频繁作为查询条件的字段

3、查询中与其他表建立关联，外键关系建立索引

4、单值/复合索引选择，在高并发下倾向复合索引

5、查询中排序的字段

6、查询中统计或分组的字段



### 哪些不建议建

1、表记录太少

2、经常增删改的表和更新的字段

3、某列数据种类太少，如性别、一些分类等

4、where条件里用不到的不建立索引 



## EXPLAIN 使用

格式：EXPLAIN + sql语句

返回信息：

1、id

select查询的序列号，一组数字，表示查询中执行select子句或者操作表的顺序。

id相同，执行顺序从上至下

id不同，如果时子查询，id的序号会递增，id值越大，优先级越高，越先被执行

id相同和不同都存在，id相同的认为一组，从上往下执行，不同组中，，id值越大，优先级越高，越先被执行



2、select type

查询类型

SIMPLE：简单的select查询，查询中不包含子查询或UNION

PRIMARY：查询中若包含任何复杂的子部分，最外层查询则被标记为

SUBQUERY：在SELECT或WHERE列表中包含子查询

DERIVED：在FROM列表中包含的子查询被标记为DERIVED(衍生)，MYSQL会递归执行这些子查询，把结果放在临时表里

UNION：若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM自居的子查询中，外层SELECT被标记为DERIVED

UNION RESULT：从UNION表获取结果的SELECT



3、table

显示这一行数据时关于哪张表的



4、type

访问类型，显示了查询使用了哪种类型，从好到坏依次为：

system > const > eq_ref > ref > fulltext > ref_or_null >index_merge > unique_subquery> index_sub_query > range > index > ALL

简化：system > const > eq_ref > ref  > range > index > ALL

一般来说，得保证查询达到range级别，最好达到ref。

system：表只有一行记录（等于系统表）。这是const类型的特例，平时不会出现，可以忽略。

const：表示通过一次索引就找到了，const用于比较primary key 或者unique索引，因为只匹配一行数据，所以很快。

eq_ref：唯一索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描。

ref：非唯一性索引扫描，返回匹配某个单独之的所有行。

range：只检索给定范围内的行，也使用到了索引，key列会显示使用到了哪个索引。一般在where语句中出现了between、> 、< 、in等查询。

index：只遍历索引树，比ALL的全表扫描快。

ALL：全表扫描。



5、possible_keys

显示可能用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引被列出，但不一定实际被使用。



6、key

查询中实际使用的索引，如果为null，则没有使用索引。如果查询中使用了覆盖索引，则该索引仅出现在key列表中。（覆盖索引：select 后面的列明与复合索引顺序列名一致，返回的数据直接从复合索引读取，不必读取表数据）



7、key_len

表示索引中使用的字节数。可通过该列计算查询中使用的索引的长度。在不损失精准性情况下，长度越短越好。显示的是该索引的最大可能长度，并非实际长度。key_len根据表定义计算而得，不是通过表内检索出的。



8、ref

显示索引的哪一列被使用了，如果可能的话，是一个常量。



9、rows

根据表统计信息及索引选用情况，大致估算查找出结果要扫描多少行。越小越好。



10、Extra

包含不适合在替他列显示但十分重要的额外信息。

Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MYSQL中无法使用索引完成的排序操作成为‘文本排序’

Using  temporary：使用了临时表保存中间结果，常见于排序order by 和group by。性能极差。

Using index：表示相应的select操作中使用了覆盖索引，不必访问表的数据行，效率很好。

Using where 使用了where来过滤条件

Using join buffer：使用了连接缓存

impossible where ：where子句的值总是false，不饿能用来获取任何元组

前三个比较常见



## 索引优化

### 索引分析

一、单表



二、两表连接

左连接：左表要全部，右表需要建立索引；

右连接：右表要全部，左表需要建立索引；

 

join语句优化

1、尽量减少循环次数，用小结果驱动大结果；

2、优先优化内层循环

3、join语句中被驱动的表上的join字段建立了索引







​                                                                     

